<h2>Java Code Coverage With JaCoCo</h2>

<h3>Source code for this article can be found <a href="https://github.com/AlexBarnes86/jacoco-demo">here</a>.</h3>

<h3>Table of Contents</h3>
<ul>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#prerequisites">Prerequisites</a></li>
	<li><a href="#local">Local Code Coverage</a></li>
	<li><a href="#remote">Remote Code Coverage</a></li>
	<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h3 id="introduction">Introduction</h3>
<p>Code coverage is an important metric that gives useful insight into what pieces of code your testing is executing or missing. According to their <a href="http://www.eclemma.org/jacoco/">website</a>, <i>"JaCoCo is a free code coverage library for Java, which has been created by the EclEmma team based on the lessons learned from using and integration existing libraries for many years."</i></p>

<ul>
	<li>JaCoCo instruments the resulting bytecode, not the source</li>
	<li>JaCoCo can pre-instrument the bytecode or run as a java agent, performing Just In Time instrumentation.</li>
	<li>JaCoCo is capable of instrumenting 1.7 bytecode</li>
</ul>

<p>Like all code coverage tools, JaCoCo is not capable of reporting how "good" your tests are, only that code is being exercised in some manner.</p>

<h3 id="prerequisites">Prerequisites</h3>
<ul>
	<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java</a></li>
	<li><a href="http://www.eclemma.org/jacoco/">JaCoCo</a></li>
	<li><a href="http://testng.org/doc/index.html">TestNG</a></li>
	<li><a href="http://ant.apache.org/">Ant</a> (Optional)</li>
	<li><a href="http://www.gradle.org/">Gradle</a> (Optional)</li>
	<li><a href="http://curl.haxx.se/">cURL</a> (Optional)</li>
</ul>

<p>It is important to have a standardized build process defined for your project (and for the sanity of your team), especially when you get to the point where you are considering adding in-depth topics such as code coverage. However, JaCoCo can be run independent of any particular build system. In this article I will demonstrate usage of JaCoCo with both Gradle (for local coverage) and Ant (for remote coverage).<p>

<h3 id="local">Local Code Coverage</h3>
<p>When using Gradle, running JaCoCo is as simple as listing the jacoco Gradle plugin. Here is the build file for our jacoco-demo project.

<h4>build.gradle</h4>
<pre><code>
apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'eclipse'
apply plugin: 'eclipse-wtp'
apply plugin: 'jacoco'

defaultTasks 'build'

group = &quot;com.toastedbits.jacoco&quot;
version = &quot;1.0-SNAPSHOT&quot;

sourceCompatibility = '1.7'
targetCompatibility = '1.7'

buildDir = 'target'

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.testng:testng:6.8.5'
	providedCompile 'org.apache.tomcat:servlet-api:6.0.37'
}

test {
    useTestNG() {
        suiteXmlBuilder().suite(name: 'jacoco demo test suite', parallel: 'tests') {
            test (name: 'all-tests') {
                packages {
                    'package' (name:'com.toastedbits.jacoco.test.*')
                }
            }
        }
    }
    ext.useDefaultListeners = true
}

eclipse {
    wtp {
        //By default gradle excludes provided dependencies with the default value for minusConfigurations,
        //We want these dependencies to appear in our eclipse project since we dont run eclipse from within the tomcat environment
        component {
            plusConfigurations += configurations.providedRuntime
            minusConfigurations = null
        }
        //The default facet configuration generated by the eclipse-wtp plugin defaults to outdated values
        //This causes unusual phony errors to be reported by eclipse when using jdk 1.7 features, let's bring them up to date
        facet {
            facet name: 'jst.web', version: '3.0'
            facet name: 'java', version: '1.7'
            facet name: 'wst.jsdt.web', version: '1.0'
        }
    }
}
</code></pre>

<p>Here since the testing is so small, we are inlining creation of the TestNG suite. This is not generally recommended, especially for larger projects. It is also best practice to create a settings.gradle so the project name doesnt change on us based on our folder name. This file also allows us to introduce multi-project build concepts into larger projects.</p>

<h4>settings.gradle</h4>
<pre><code>
rootProject.name = 'jacoco-demo'
</code></pre>

The demo project is laid out according to standard java builds used by Gradle (and Maven).</p>

<pre><code>
build.gradle
settings.gradle
src/main/java/com/toastedbits/jacoco/
	JaCoCoDemo.java
	DemoServlet.java
src/main/webapp/WEB-INF/
	web.xml
src/test/java
	DemoTest.java
</code></pre>

<p>For now we will ignore the webapp related code (servlet and web.xml) and focus only on the DemoTest and JaCoCoDemo classes.</p>

<h4>DemoTest.java</h4>
<pre><code>
package com.toastedbits.jacoco.test;

import static org.testng.Assert.*;
import java.sql.SQLException;
import org.testng.annotations.Test;
import com.toastedbits.jacoco.JaCoCoDemo;

public class DemoTest {
	@Test
	public void testGetConnection() throws SQLException {
		JaCoCoDemo jccd = new JaCoCoDemo();
		assertEquals(42, jccd.calculateAnswer(&quot;What is the answer to the ultimate question of life, the universe and everything?&quot;));
	}
}
</code></pre>

<h4>JaCoCoDemo.java</h4>
<pre><code>
package com.toastedbits.jacoco;

public class JaCoCoDemo {
	private static final int ANSWER = 42;
	private static final int WRONG_ANSWER = 314159;
	
	public int calculateAnswer(String question) {
		if(question.contains(&quot;life&quot;)) {
			return ANSWER;
		}
		else {
			return WRONG_ANSWER;
		}
	}
}
</pre></code>

<p>Not too much going on here, just unit testing a simple class named JaCoCoDemo that contains a method returning 42 if the question contains the string &quot;life&quot;. I left out the negative test so we get a more interesting picture when running JaCoCo.</p>

<p>We can execute our local tests and see the JaCoCo report by executing <i>gradle jacoco</i> in the root project folder. JaCoCo reports can then be found in <i>target/reports/jacoco</i></p>

<p>See Gradle's documentation on the <a href="http://www.gradle.org/docs/current/userguide/jacoco_plugin.html">JaCoCo plugin</a> for more information</p>

<h3 id="remote">Remote Code Coverage</h3>
<p>Now that we have a simple understanding of what JaCoCo can do for us, lets remove some of the magic that Gradle performs for us and move into Ant so we can see what really goes on behind the scenes. I have created a simple Ant build.xml that builds the war file and generates coverage reports generated from integration tests against a basic servlet that makes use of the same JaCoCoDemo class. Here we will stub our integration tests with cURL, but your project may wish to integrate more with TestNG by using Apache HttpComponents, Selenium, etc.</p>

<p>First we need to ensure our container environment has the jacocoagent.jar on its classpath and is used as a <a href="http://www.javaworld.com/javaworld/jw-06-1998/jw-06-howto.html">java agent</a>. For Tomcat, this means we must add jacocoagent.jar to $TOMCAT_HOME/lib and ensure Tomcat's execution environment has CATALINA_OPTS set to use the agent:</p>

<pre><code>
CATALINA_OPTS=&quot;$CATALINA_OPTS -javaagent:$TOMCAT_HOME/lib/jacocoagent.jar=append=false,dumponexit=false,output=tcpserver,address=*,port=6300,excludes=com.example.excludeme*&quot;
</code></pre>

<p>Some useful tips:</p>
<ul>
	<li>This can be added to the top of $TOMCAT_HOME/bin/catalina.sh to enforce jacoco to always run.</li>
	<li>Also a good oportunity to allow access to jvisualvm (java profiler) with <code>JAVA_OPTS=&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote.port=8086 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;</code></li>
	<li>Remember to open port 6300, disable SELinux, etc on the host running Tomcat</li>
</ul>

<p>Here are the steps needed to generate a jacoco report for a remote host:
<ol>
	<li>Build the war file with ant or gradle (default targets build the war)</li>
	<li>execute <i>curl -k -v &quot;http://example.com/jacoco-demo/?q=What%20is%20the%20meaning%20of%20life%20the%20universe%20and%20everything&quot;</i></li>
	<li>execute: <i>ant jacocoReport</i></li>
	<li>open: target/report/index.html</li>
</ol>

<p>The webapp itself is very basic</p>

<h4>web.xml</h4>
<pre><code>
&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
		 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
		 xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
		 version=&quot;3.0&quot;&gt;
	
	&lt;servlet&gt;
		&lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt;
		&lt;servlet-class&gt;com.toastedbits.jacoco.DemoServlet&lt;/servlet-class&gt;
	&lt;/servlet&gt;

	&lt;servlet-mapping&gt;
		&lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt;
		&lt;url-pattern&gt;/&lt;/url-pattern&gt;
	&lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<h4>DemoServlet.java</h4>
<pre><code>
package com.toastedbits.jacoco;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class DemoServlet extends HttpServlet {
	private static final long serialVersionUID = -7485296299041069908L;
	
	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
		String question = request.getParameter(&quot;q&quot;);
		
		PrintWriter pw = response.getWriter();
		pw.print(&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&quot;utf-8\&quot;&gt;&lt;title&gt;Answer&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);
		
		if(question != null) {
			pw.print(&quot;&lt;p&gt;Question: &quot; + question + &quot;&lt;br&gt;&quot;);
			pw.print(&quot;Answer: &quot; + new JaCoCoDemo().calculateAnswer(question) + &quot;&lt;/p&gt;&quot;);
		}
		else {
			pw.print(&quot;&lt;p&gt;Pose a question with the q request parameter&lt;/p&gt;&quot;);
		}
		
		pw.print(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);
		
		pw.flush();
	}
}
</code></pre>

<h4>build.xml</h4>
<pre><code>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;!DOCTYPE project&gt;
&lt;project name=&quot;jacoco-demo&quot; basedir=&quot;.&quot; default=&quot;build&quot; xmlns:jacoco=&quot;antlib:org.jacoco.ant&quot;&gt;
	&lt;property name=&quot;sourceCompatibility&quot; value=&quot;1.7&quot;/&gt;
	&lt;property name=&quot;targetCompatibility&quot; value=&quot;1.7&quot;/&gt;
	
	&lt;property name=&quot;target&quot; location=&quot;${basedir}/target&quot;/&gt;
	&lt;property name=&quot;target.classes&quot; location=&quot;${target}/classes&quot;/&gt;
	&lt;property name=&quot;target.classes.main&quot; location=&quot;${target.classes}/main&quot;/&gt;
	&lt;property name=&quot;src.main&quot; location=&quot;${basedir}/src/main&quot;/&gt;
	&lt;property name=&quot;src.main.java&quot; location=&quot;${src.main}/java&quot;/&gt;
	&lt;property name=&quot;src.main.webapp&quot; location=&quot;src/main/webapp&quot;/&gt;
	&lt;property name=&quot;webinf.dir&quot; location=&quot;${src.main.webapp}/WEB-INF&quot;/&gt;
	&lt;property name=&quot;metainf.dir&quot; location=&quot;${src.main.webapp}/META-INF&quot;/&gt;
	
	&lt;property name=&quot;war.file.name&quot; value=&quot;jacoco-demo.war&quot;/&gt;
	
	&lt;property name=&quot;jacoco.host&quot; value=&quot;rcdn6-vm63-54&quot;/&gt;
	&lt;property name=&quot;jacoco.port&quot; value=&quot;6300&quot;/&gt;
	&lt;property name=&quot;jacoco.datafile&quot; value=&quot;${coverage.dir}/jacoco.exec&quot;/&gt;
	
	&lt;path id=&quot;compile.classpath&quot;&gt;
	&lt;/path&gt;
	
	&lt;path id=&quot;providedCompile.classpath&quot;&gt;
		&lt;fileset dir=&quot;${basedir}/lib&quot; includes=&quot;servlet-api*.jar&quot;/&gt;
	&lt;/path&gt;
	
	&lt;target name=&quot;build&quot; depends=&quot;war&quot;/&gt;
	
	&lt;target name=&quot;war&quot; depends=&quot;compile&quot;&gt;
		&lt;war destfile=&quot;${target}/${war.file.name}&quot; webxml=&quot;${webinf.dir}/web.xml&quot; compress=&quot;false&quot;&gt;
			&lt;metainf dir=&quot;${metainf.dir}&quot;/&gt;
			 &lt;!-- The webinf task is a little dumb, it thinks classes and libs should be in with our source tree and wants to re-include the web.xml, exclude them for better control --&gt;
			&lt;webinf dir=&quot;${webinf.dir}&quot;&gt;
				&lt;exclude name=&quot;web.xml&quot;/&gt;
				&lt;exclude name=&quot;classes/**&quot;/&gt;
				&lt;exclude name=&quot;lib/**&quot;/&gt;
			&lt;/webinf&gt;
			&lt;classes dir=&quot;${target.classes.main}&quot;/&gt;
			&lt;lib dir=&quot;${webinf.dir}/lib&quot;/&gt;
			&lt;fileset dir=&quot;${src.main.webapp}&quot;&gt;
				&lt;exclude name=&quot;WEB-INF/**&quot;/&gt;
				&lt;exclude name=&quot;META-INF/**&quot;/&gt;
			&lt;/fileset&gt;
		&lt;/war&gt;
	&lt;/target&gt;
	
	&lt;target name=&quot;compile&quot;&gt;
		&lt;mkdir dir=&quot;${target.classes.main}&quot;/&gt;
		&lt;javac
			debug=&quot;true&quot;
			srcdir=&quot;${src.main.java}&quot;
			destdir=&quot;${target.classes.main}&quot;
			source=&quot;${sourceCompatibility}&quot;
			target=&quot;${targetCompatibility}&quot;
			includeantruntime=&quot;false&quot;
			fork=&quot;true&quot;&gt;
			
			&lt;classpath refid=&quot;compile.classpath&quot;/&gt;
			&lt;classpath refid=&quot;providedCompile.classpath&quot;/&gt;
		&lt;/javac&gt;
	&lt;/target&gt;
	
    &lt;taskdef uri=&quot;antlib:org.jacoco.ant&quot; resource=&quot;org/jacoco/ant/antlib.xml&quot;&gt;
		&lt;classpath path=&quot;${basedir}/lib/jacocoant.jar&quot;/&gt;
	&lt;/taskdef&gt;
	
	&lt;target name=&quot;jacocoReport&quot;&gt;
		&lt;delete file=&quot;${jacoco.datafile}&quot; /&gt;
		&lt;jacoco:dump address=&quot;${jacoco.host}&quot; port=&quot;${jacoco.port}&quot; dump=&quot;true&quot; reset=&quot;true&quot; destfile=&quot;${target}/remote.exec&quot; append=&quot;false&quot;/&gt;
		&lt;jacoco:report&gt;
			&lt;executiondata&gt;
				&lt;file file=&quot;${target}/remote.exec&quot;/&gt;
			&lt;/executiondata&gt;
			&lt;structure name=&quot;Coverage&quot;&gt;
				&lt;classfiles&gt;
					&lt;fileset dir=&quot;${target}/classes&quot;/&gt;
				&lt;/classfiles&gt;
				&lt;sourcefiles encoding=&quot;UTF-8&quot;&gt;
					&lt;fileset dir=&quot;src&quot;/&gt;
				&lt;/sourcefiles&gt;
			&lt;/structure&gt;
			&lt;html destdir=&quot;${target}/report&quot;/&gt;
			&lt;xml destfile=&quot;${target}/report/report.xml&quot;/&gt;
		&lt;/jacoco:report&gt;
	&lt;/target&gt;
	
	&lt;target name=&quot;clean&quot;&gt;
		&lt;delete dir=&quot;${target}&quot;/&gt;
	&lt;/target&gt;
&lt;/project&gt;
</code></pre>

<p>Troubleshooting: Jacoco dynamically instruments classes with private data. If tomcat fails to start or you encounter other bugs with jacoco reporting, check for code that performs unsafe reflection (iterating through all members of a class without validating access level) may need to be excluded or rewritten.</p>

<h2 id="conclusion">Conclusion</h2>
<p>Code coverage gives important insight into the testing of your code, but this power is even greater when included as part of your daily workflow. JaCoCo reporting doesn't have to be a manual process. I recommend adding it as part of a larger automated workflow with Git, Gerrit, Jenkins, and Sonar. The best part is all of this is free and open source! Setting up a workflow for your team may cost a few days up front, but the gains far outweigh any initial time investment.</p>
